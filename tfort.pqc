void (entity Goal, entity Player, entity Item) DisplayItemStatus;
void (entity Item, entity AP, float method) tfgoalitem_RemoveFromPlayer;
void () TeamFortress_CheckClassStats;
void (entity Player, float Armorclass) TeamFortress_DescribeArmor;
void () TeamFortress_AmmoboxTouch;
float (float tno) num_team_ammoboxes;
void (float tno) RemoveOldAmmobox;
void (float tno) increment_team_ammoboxes;
void (float tno) decrement_team_ammoboxes;
void () TeamFortress_ExplodePerson;
void (string halias, float himpulse1, float himpulse2) TeamFortress_Alias;
void () TeamFortress_Regenerate;
void () TeamFortress_CheckforCheats;
void () TeamFortress_RegenerateCells;

void () UseSpecialSkill =
{
	local vector src;

	self.impulse = TF_FLARE_LIT;
	if ((self.playerclass == TF_FLARE_OFF))
	{
		self.impulse = 163;
	}
	else
	{
		if ((self.playerclass == BOT_FIGHTING))
		{
			self.impulse = 174;
		}
		else
		{
			if ((self.playerclass == BOT_AI_FOLLOW))
			{
				self.impulse = 173;
			}
			else
			{
				if ((self.playerclass == BOT_MOVING))
				{
					self.impulse = 170;
				}
				else
				{
					if ((self.playerclass == BOT_AI_GRAPPLE))
					{
						self.impulse = 176;
					}
					else
					{
						if ((self.playerclass == BOT_AI_FLEE))
						{
							self.impulse = BOT_AI_BLAST;
						}
						else
						{
							if ((self.playerclass == BOT_AI_BLAST))
							{
								self.impulse = BOT_AI_FLEE;
							}
							else
							{
								if ((self.playerclass == BOT_DEFEND))
								{
									self.impulse = 177;
								}
								else
								{
									if ((self.playerclass == BOT_AI_FLAGRUN))
									{
										self.impulse = 179;
									}
									else
									{
										if ((self.playerclass == TF_FLARE_LIT))
										{
											if ((self.enemy == world))
											{
												src = (self.origin + (v_forward * BOT_AI_SCOUT));
												src_z = (self.absmin_z + (self.size_z * 0.7));
												traceline (src, (src + (v_forward * FL_WATERJUMP)), TF_FLARE_LIT, self);
												if (((trace_ent != world) && (trace_ent.origin != world.origin)))
												{
													sprint3 (self, BOT_FIGHTING, "Locked onto ", trace_ent.classname, "\n");
													self.enemy = trace_ent;
													self.camdist = vlen ((self.enemy.origin - self.origin));
													self.camangle = (self.origin - self.enemy.origin);
													self.camangle_z = (TF_FLARE_LIT - self.camangle_z);
													self.camangle = vectoangles (self.camangle);
												}
											}
											else
											{
												sprint (self, BOT_FIGHTING, "Removed Lock\n");
												self.enemy = world;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};

void () TeamFortress_ChangeClass =
{
	local entity spot;
	local entity te;
	local float tc;
	local string st;

	if ((self.playerclass != TF_FLARE_LIT))
	{
		if ((deathmatch != BOT_AI_FOLLOW))
		{
			return;
		}
		if (TeamFortress_TeamIsCivilian (self.team_no))
		{
			sprint (self, BOT_FIGHTING, "You cannot change class.\n");
			return;
		}
		if (!IsLegalClass ((self.impulse - 100)))
		{
			sprint (self, BOT_FIGHTING, "Your team cannot play that class.\n");
			TeamFortress_DisplayLegalClasses ();
			return;
		}
		if (((spy_off == TF_FLARE_OFF) && ((self.impulse - 100) == BOT_DEFEND)))
		{
			sprint (self, BOT_FIGHTING, "The spy class has been disabled on the server by the administrator.\n");
			return;
		}
		self.nextpc = (self.impulse - 100);
		sprint (self, BOT_FIGHTING, "After dying, you will return as a ");
		TeamFortress_PrintClassName (self, self.nextpc, (self.tfstate & BOT_DEFEND));
		self.immune_to_check = (time + BOT_AI_SCOUT);
		return;
	}
	if ((teamplay && (self.team_no == TF_FLARE_LIT)))
	{
		if ((toggleflags & 64))
		{
			if ((TeamFortress_TeamPutPlayerInTeam () == TF_FLARE_LIT))
			{
				return;
			}
		}
		else
		{
			sprint (self, BOT_FIGHTING, "You must join a team first. \n");
			sprint (self, BOT_FIGHTING, "use imin1, imin2, imin3, or imin4\n");
			return;
		}
	}
	if ((self.lives == TF_FLARE_LIT))
	{
		sprint (self, BOT_FIGHTING, "You have no lives left.\n");
		return;
	}
	if ((!IsLegalClass ((self.impulse - 100)) && (self.impulse != TF_FLARE_OFF)))
	{
		sprint (self, BOT_FIGHTING, "You cannot play that playerclass on this map. \n");
		TeamFortress_DisplayLegalClasses ();
		return;
	}
	if (((spy_off == TF_FLARE_OFF) && ((self.impulse - 100) == BOT_DEFEND)))
	{
		sprint (self, BOT_FIGHTING, "The spy class has been disabled on the server by the administrator.\n");
		return;
	}
	if ((self.impulse != TF_FLARE_OFF))
	{
		self.playerclass = (self.impulse - 100);
	}
	else
	{
		self.playerclass = 11;
	}
	self.nextpc = TF_FLARE_LIT;
	self.takedamage = BOT_FIGHTING;
	self.movetype = BOT_AI_FOLLOW;
	self.flags = (BOT_DEFEND | FL_ONGROUND);
	self.waterlevel = TF_FLARE_LIT;
	self.air_finished = (time + 12);
	self.solid = BOT_AI_FOLLOW;
	self.pausetime = TF_FLARE_LIT;
	spot = SelectSpawnPoint ();
	self.origin = (spot.origin + '0 0 1');
	self.angles = spot.angles;
	self.fixangle = TF_FLARE_OFF;
	setmodel (self, string_null);
	modelindex_null = self.modelindex;
	setmodel (self, "progs/eyes.mdl");
	modelindex_eyes = self.modelindex;
	setmodel (self, "progs/player.mdl");
	modelindex_player = self.modelindex;
	setsize (self, VEC_HULL_MIN, VEC_HULL_MAX);
	if ((self.playerclass == TF_FLARE_OFF))
	{
		setsize (self, '-8 -8 -24', '8 8 32');
	}
	self.view_ofs = '0 0 22';
	player_stand1 ();
	if ((deathmatch || coop))
	{
		makevectors (self.angles);
		spawn_tfog ((self.origin + (v_forward * 20)));
	}
	if ((self.playerclass == BOT_AI_SCOUT))
	{
		sprint (self, BOT_FIGHTING, "Random Playerclass.\n");
		self.tfstate = (self.tfstate | BOT_DEFEND);
		self.playerclass = (TF_FLARE_OFF + floor ((random () * (BOT_AI_SCOUT - TF_FLARE_OFF))));
	}
	if ((spot.classname == "info_player_teamspawn"))
	{
		if ((spot.items != TF_FLARE_LIT))
		{
			te = Finditem (spot.items);
			if (te)
			{
				tfgoalitem_GiveToPlayer (te, self, self);
			}
			if (!(spot.goal_activation & TF_FLARE_OFF))
			{
				spot.items = TF_FLARE_LIT;
			}
		}
		if (spot.message)
		{
			CenterPrint (self, spot.message);
			if (!(spot.goal_activation & BOT_FIGHTING))
			{
				spot.message = string_null;
			}
		}
		if ((spot.goal_effects == TF_FLARE_OFF))
		{
			spot.classname = "deadpoint";
			spot.team_str_home = string_null;
			spot.nextthink = (time + TF_FLARE_OFF);
			spot.think = SUB_Remove;
		}
	}
	spot = find (world, classname, "player");
	while (spot)
	{
		if (((spot.team_no == self.team_no) && (spot != self)))
		{
			sprint (spot, BOT_FIGHTING, self.netname);
			sprint (spot, BOT_FIGHTING, " is playing as a ");
			TeamFortress_PrintClassName (spot, self.playerclass, (self.tfstate & BOT_DEFEND));
		}
		spot = find (spot, classname, "player");
	}
	TeamFortress_PrintClassName (self, self.playerclass, (self.tfstate & BOT_DEFEND));
	TeamFortress_SetEquipment ();
	TeamFortress_SetHealth ();
	TeamFortress_SetSpeed (self);
	TeamFortress_SetSkin (self);
};

void () TeamFortress_DisplayLegalClasses =
{
	local float gotone;
	local float ill;

	sprint (self, BOT_FIGHTING, "Legal Classes for your team are:\n");
	gotone = TF_FLARE_LIT;
	ill = TeamFortress_TeamGetIllegalClasses (self.team_no);
	if ((!(illegalclasses & TF_FLARE_OFF) && !(ill & TF_FLARE_OFF)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "Scout");
	}
	if ((!(illegalclasses & BOT_FIGHTING) && !(ill & BOT_FIGHTING)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "Sniper");
	}
	if ((!(illegalclasses & BOT_MOVING) && !(ill & BOT_MOVING)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "Soldier");
	}
	if ((!(illegalclasses & BOT_DEFEND) && !(ill & BOT_DEFEND)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "Demolitions Man");
	}
	if ((!(illegalclasses & BOT_RESUPPLYING) && !(ill & BOT_RESUPPLYING)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "Combat Medic");
	}
	if ((!(illegalclasses & BOT_AVOIDING_HAZARD) && !(ill & BOT_AVOIDING_HAZARD)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "Heavy Weapons Guy");
	}
	if ((!(illegalclasses & 64) && !(ill & 64)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "Pyro");
	}
	if ((!(illegalclasses & FL_ITEM) && !(ill & FL_ITEM)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "Spy");
	}
	if ((!(illegalclasses & FL_ONGROUND) && !(ill & FL_ONGROUND)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "Engineer");
	}
	if ((!(illegalclasses & 128) && !(ill & 128)))
	{
		if (gotone)
		{
			sprint (self, BOT_FIGHTING, ", ");
		}
		gotone = TF_FLARE_OFF;
		sprint (self, BOT_FIGHTING, "RandomPC");
	}
	sprint (self, BOT_FIGHTING, "\n");
};

void () TeamFortress_Inventory =
{
	local entity tg;
	local string ac;
	local float col;

	col = TeamFortress_TeamGetColor (self.team_no);
	sprint (self, BOT_FIGHTING, "You're in team ");
	ac = ftos (self.team_no);
	sprint (self, BOT_FIGHTING, ac);
	sprint (self, BOT_FIGHTING, ", color ");
	ac = ftos (col);
	sprint (self, BOT_FIGHTING, ac);
	sprint (self, BOT_FIGHTING, ".\n");
	if ((self.lives != CONTENT_EMPTY))
	{
		ac = ftos (self.lives);
		sprint (self, BOT_FIGHTING, "You've got ");
		sprint (self, BOT_FIGHTING, ac);
		if ((self.lives == TF_FLARE_OFF))
		{
			sprint (self, BOT_FIGHTING, " life.\n");
		}
		else
		{
			sprint (self, BOT_FIGHTING, " lives.\n");
		}
	}
	if ((self.no_grenades_1 > TF_FLARE_LIT))
	{
		sprint (self, BOT_FIGHTING, "Gren.Type 1 : ");
		if ((self.tp_grenades_1 == TF_FLARE_OFF))
		{
			sprint (self, BOT_FIGHTING, " Normal(");
		}
		else
		{
			if ((self.tp_grenades_1 == BOT_FIGHTING))
			{
				sprint (self, BOT_FIGHTING, " Concussion(");
			}
			else
			{
				if ((self.tp_grenades_1 == BOT_AI_FOLLOW))
				{
					sprint (self, BOT_FIGHTING, " Nail(");
				}
				else
				{
					if ((self.tp_grenades_1 == BOT_MOVING))
					{
						sprint (self, BOT_FIGHTING, " Mirv(");
					}
					else
					{
						if ((self.tp_grenades_1 == BOT_AI_GRAPPLE))
						{
							sprint (self, BOT_FIGHTING, " Napalm(");
						}
						else
						{
							if ((self.tp_grenades_1 == BOT_AI_FLEE))
							{
								sprint (self, BOT_FIGHTING, " Flare(");
							}
							else
							{
								if ((self.tp_grenades_1 == BOT_AI_BLAST))
								{
									sprint (self, BOT_FIGHTING, " Hallucinogenic(");
								}
								else
								{
									if ((self.tp_grenades_1 == BOT_DEFEND))
									{
										sprint (self, BOT_FIGHTING, " EMP(");
									}
									else
									{
										if ((self.tp_grenades_1 == BOT_AI_FLAGRUN))
										{
											sprint (self, BOT_FIGHTING, " Flash(");
										}
										else
										{
											sprint (self, BOT_FIGHTING, "BUG(");
										}
									}
								}
							}
						}
					}
				}
			}
		}
		ac = ftos (self.no_grenades_1);
		sprint (self, BOT_FIGHTING, ac);
		sprint (self, BOT_FIGHTING, ")\n");
	}
	if ((self.no_grenades_2 > TF_FLARE_LIT))
	{
		sprint (self, BOT_FIGHTING, "Gren.Type 2 : ");
		if ((self.tp_grenades_2 == TF_FLARE_OFF))
		{
			sprint (self, BOT_FIGHTING, " Normal(");
		}
		else
		{
			if ((self.tp_grenades_2 == BOT_FIGHTING))
			{
				sprint (self, BOT_FIGHTING, " Concussion(");
			}
			else
			{
				if ((self.tp_grenades_2 == BOT_AI_FOLLOW))
				{
					sprint (self, BOT_FIGHTING, " Nail(");
				}
				else
				{
					if ((self.tp_grenades_2 == BOT_MOVING))
					{
						sprint (self, BOT_FIGHTING, " Mirv(");
					}
					else
					{
						if ((self.tp_grenades_2 == BOT_AI_GRAPPLE))
						{
							sprint (self, BOT_FIGHTING, " Napalm(");
						}
						else
						{
							if ((self.tp_grenades_2 == BOT_AI_FLEE))
							{
								sprint (self, BOT_FIGHTING, " Flare(");
							}
							else
							{
								if ((self.tp_grenades_2 == BOT_AI_BLAST))
								{
									sprint (self, BOT_FIGHTING, " Hallucinogenic(");
								}
								else
								{
									if ((self.tp_grenades_2 == BOT_DEFEND))
									{
										sprint (self, BOT_FIGHTING, " EMP(");
									}
									else
									{
										if ((self.tp_grenades_2 == BOT_AI_FLAGRUN))
										{
											sprint (self, BOT_FIGHTING, " Flash(");
										}
										else
										{
											sprint (self, BOT_FIGHTING, "BUG(");
										}
									}
								}
							}
						}
					}
				}
			}
		}
		ac = ftos (self.no_grenades_2);
		sprint (self, BOT_FIGHTING, ac);
		sprint (self, BOT_FIGHTING, ")\n");
	}
	if ((self.tf_items & TF_FLARE_OFF))
	{
		sprint (self, BOT_FIGHTING, "Scanner. ");
	}
	if ((self.weapons_carried & BOT_MOVING))
	{
		sprint (self, BOT_FIGHTING, "Medikit (");
		ac = ftos (self.ammo_medikit);
		sprint (self, BOT_FIGHTING, ac);
		sprint (self, BOT_FIGHTING, ") ");
	}
	if ((self.weapons_carried & 131072))
	{
		if ((self.ammo_detpack > TF_FLARE_LIT))
		{
			ac = ftos (self.ammo_detpack);
			sprint (self, BOT_FIGHTING, ac);
			sprint (self, BOT_FIGHTING, " Detpack");
			if ((self.ammo_detpack > TF_FLARE_OFF))
			{
				sprint (self, BOT_FIGHTING, "s");
			}
			sprint (self, BOT_FIGHTING, ". ");
		}
	}
	tg = find (world, classname, "item_tfgoal");
	while (tg)
	{
		if ((tg.owner == self))
		{
			sprint (self, BOT_FIGHTING, tg.netname);
			sprint (self, BOT_FIGHTING, ". ");
		}
		tg = find (tg, classname, "item_tfgoal");
	}
	if ((self.armorvalue > TF_FLARE_LIT))
	{
		TeamFortress_DescribeArmor (self, self.armorclass);
	}
	if (!invis_only)
	{
		if (((self.playerclass == BOT_DEFEND) && (invis_only == TF_FLARE_LIT)))
		{
			sprint (self, BOT_FIGHTING, "Skin : ");
			if ((self.undercover_skin != TF_FLARE_LIT))
			{
				TeamFortress_PrintClassName (self, self.undercover_skin, TF_FLARE_LIT);
			}
			else
			{
				sprint (self, BOT_FIGHTING, "Spy\n");
			}
			sprint (self, BOT_FIGHTING, "Colors : Team ");
			if ((self.undercover_team != TF_FLARE_LIT))
			{
				ac = ftos (self.undercover_team);
			}
			else
			{
				ac = ftos (self.team_no);
			}
			sprint (self, BOT_FIGHTING, ac);
		}
	}
	sprint (self, BOT_FIGHTING, "\n");
};

void () TeamFortress_ShowTF =
{
	local string st;

	if ((toggleflags & TF_FLARE_OFF))
	{
		sprint (self, BOT_FIGHTING, "Class Persistence On.\n");
	}
	else
	{
		sprint (self, BOT_FIGHTING, "Class Persistence Off.\n");
	}
	if ((toggleflags & BOT_FIGHTING))
	{
		sprint (self, BOT_FIGHTING, "Cheat Checking On.\n");
	}
	else
	{
		sprint (self, BOT_FIGHTING, "Cheat Checking Off.\n");
	}
	if ((toggleflags & 64))
	{
		sprint (self, BOT_FIGHTING, "AutoTeam On.\n");
	}
	else
	{
		sprint (self, BOT_FIGHTING, "AutoTeam Off.\n");
	}
	if ((toggleflags & BOT_MOVING))
	{
		st = ftos (respawn_delay_time);
	}
	else
	{
		st = "No";
	}
	sprint (self, BOT_FIGHTING, st);
	if ((st != "No"))
	{
		sprint (self, BOT_FIGHTING, " second");
	}
	sprint (self, BOT_FIGHTING, " Respawn Delay.\n");
	if ((toggleflags & 128))
	{
		sprint (self, BOT_FIGHTING, "TeamFrags On.\n");
	}
	else
	{
		sprint (self, BOT_FIGHTING, "TeamFrags Off.\n");
	}
	if (allow_hook)
	{
		sprint (self, BOT_FIGHTING, "Grapple On.\n");
	}
	else
	{
		sprint (self, BOT_FIGHTING, "Grapple Off.\n");
	}
};
void () TeamFortress_GrenadePrimed;

void () TeamFortress_PrimeGrenade =
{
	local float gtype;
	local string gs;
	local string ptime;
	local entity tGrenade;

	if (((self.tfstate & TF_FLARE_OFF) || (self.tfstate & FL_PARTIALGROUND)))
	{
		return;
	}
	if ((self.impulse == 150))
	{
		gtype = self.tp_grenades_1;
		if ((self.tp_grenades_1 == BOT_FIGHTING))
		{
			gs = "Concussion grenade";
		}
		else
		{
			if ((self.tp_grenades_1 == BOT_AI_FOLLOW))
			{
				gs = "Nail grenade";
			}
			else
			{
				if ((self.tp_grenades_1 == BOT_MOVING))
				{
					gs = "Mirv grenade";
				}
				else
				{
					if ((self.tp_grenades_1 == BOT_AI_GRAPPLE))
					{
						gs = "Napalm grenade";
					}
					else
					{
						if ((self.tp_grenades_1 == BOT_AI_FLEE))
						{
							gs = "Flare";
						}
						else
						{
							if ((self.tp_grenades_1 == BOT_AI_BLAST))
							{
								gs = "Gas grenade";
							}
							else
							{
								if ((self.tp_grenades_1 == BOT_DEFEND))
								{
									gs = "EMP grenade";
								}
								else
								{
									if ((self.tp_grenades_1 == BOT_AI_FLAGRUN))
									{
										gs = "Flash grenade";
									}
									else
									{
										gs = "Grenade";
									}
								}
							}
						}
					}
				}
			}
		}
		if ((self.no_grenades_1 > TF_FLARE_LIT))
		{
			ptime = ftos (BOT_AI_FOLLOW);
			sprint (self, BOT_FIGHTING, gs);
			sprint (self, BOT_FIGHTING, " primed, ");
			sprint (self, BOT_FIGHTING, ptime);
			sprint (self, BOT_FIGHTING, " seconds...\n");
			self.no_grenades_1 = (self.no_grenades_1 - TF_FLARE_OFF);
		}
		else
		{
			sprint (self, BOT_FIGHTING, "No ");
			sprint (self, BOT_FIGHTING, gs);
			sprint (self, BOT_FIGHTING, "s left.\n");
			return;
		}
	}
	if ((self.impulse == 151))
	{
		gtype = self.tp_grenades_2;
		if ((self.tp_grenades_2 == BOT_FIGHTING))
		{
			gs = "Concussion grenade";
		}
		else
		{
			if ((self.tp_grenades_2 == BOT_AI_FOLLOW))
			{
				gs = "Nail grenade";
			}
			else
			{
				if ((self.tp_grenades_2 == BOT_MOVING))
				{
					gs = "Mirv grenade";
				}
				else
				{
					if ((self.tp_grenades_2 == BOT_AI_GRAPPLE))
					{
						gs = "Napalm grenade";
					}
					else
					{
						if ((self.tp_grenades_2 == BOT_AI_FLEE))
						{
							gs = "Flare";
						}
						else
						{
							if ((self.tp_grenades_2 == BOT_AI_BLAST))
							{
								gs = "Gas grenade";
							}
							else
							{
								if ((self.tp_grenades_2 == BOT_DEFEND))
								{
									gs = "EMP grenade";
								}
								else
								{
									if ((self.tp_grenades_2 == BOT_AI_FLAGRUN))
									{
										gs = "Flash grenade";
									}
									else
									{
										gs = "Grenade";
									}
								}
							}
						}
					}
				}
			}
		}
		if ((self.no_grenades_2 > TF_FLARE_LIT))
		{
			ptime = ftos (BOT_AI_FOLLOW);
			sprint (self, BOT_FIGHTING, gs);
			sprint (self, BOT_FIGHTING, " primed, ");
			sprint (self, BOT_FIGHTING, ptime);
			sprint (self, BOT_FIGHTING, " seconds...\n");
			self.no_grenades_2 = (self.no_grenades_2 - TF_FLARE_OFF);
		}
		else
		{
			sprint (self, BOT_FIGHTING, "No ");
			sprint (self, BOT_FIGHTING, gs);
			sprint (self, BOT_FIGHTING, "s left.\n");
			return;
		}
	}
	self.tfstate = (self.tfstate | TF_FLARE_OFF);
	tGrenade = spawn ();
	tGrenade.owner = self;
	tGrenade.weapon = gtype;
	tGrenade.classname = "GrenadeTimer";
	tGrenade.nextthink = (time + 0.8);
	tGrenade.heat = ((time + BOT_AI_FOLLOW) + 0.8);
	tGrenade.think = TeamFortress_GrenadePrimed;
};

void () TeamFortress_GrenadePrimed =
{
	local entity user;
	local entity oldself;

	user = self.owner;
	if ((!(user.tfstate & FL_PARTIALGROUND) && !user.deadflag))
	{
		self.nextthink = (time + 0.1);
		if (!self.think)
		{
			dremove (self);
		}
		if ((time > self.heat))
		{
			TeamFortress_ExplodePerson ();
		}
		return;
	}
	if (!(user.tfstate & TF_FLARE_OFF))
	{
		dprint ("GrenadePrimed logic error\n");
	}
	user.tfstate = (user.tfstate - (user.tfstate & TF_FLARE_OFF));
	user.tfstate = (user.tfstate - (user.tfstate & FL_PARTIALGROUND));
	sound (user, TF_FLARE_OFF, "weapons/grenade.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	KickPlayer (CONTENT_EMPTY, user);
	newmis = spawn ();
	newmis.owner = user;
	newmis.movetype = BOT_AI_SCOUT;
	newmis.solid = BOT_FIGHTING;
	newmis.classname = "grenade";
	makevectors (user.v_angle);
	if (user.deadflag)
	{
		newmis.velocity = '0 0 200';
	}
	else
	{
		if (user.v_angle_x)
		{
			newmis.velocity = ((((v_forward * 600) + (v_up * BOT_IMPULSE)) + ((crandom () * v_right) * BOT_AI_SCOUT)) + ((crandom () * v_up) * BOT_AI_SCOUT));
		}
		else
		{
			newmis.velocity = aim (user, 10000);
			newmis.velocity = (newmis.velocity * 600);
			newmis.velocity_z = BOT_IMPULSE;
		}
	}
	newmis.angles = vectoangles (newmis.velocity);
	newmis.think = SUB_Null;
	newmis.nextthink = self.heat;
	if ((self.weapon == TF_FLARE_OFF))
	{
		newmis.touch = NormalGrenadeTouch;
		newmis.think = NormalGrenadeExplode;
		newmis.skin = TF_FLARE_LIT;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else
	{
		if ((self.weapon == BOT_FIGHTING))
		{
			newmis.touch = ConcussionGrenadeTouch;
			newmis.think = ConcussionGrenadeExplode;
			newmis.skin = TF_FLARE_OFF;
			newmis.avelocity = '300 300 300';
			setmodel (newmis, "progs/hgren2.mdl");
		}
		else
		{
			if ((self.weapon == BOT_AI_FOLLOW))
			{
				newmis.touch = NailGrenadeTouch;
				newmis.think = NailGrenadeExplode;
				newmis.skin = TF_FLARE_OFF;
				newmis.avelocity = '0 300 0';
				setmodel (newmis, "progs/biggren.mdl");
			}
			else
			{
				if ((self.weapon == BOT_MOVING))
				{
					newmis.touch = MirvGrenadeTouch;
					newmis.think = MirvGrenadeExplode;
					newmis.skin = TF_FLARE_LIT;
					newmis.avelocity = '0 300 0';
					setmodel (newmis, "progs/biggren.mdl");
				}
				else
				{
					if ((self.weapon == BOT_AI_GRAPPLE))
					{
						newmis.touch = NapalmGrenadeTouch;
						newmis.think = NapalmGrenadeExplode;
						newmis.skin = BOT_FIGHTING;
						newmis.avelocity = '0 300 0';
						setmodel (newmis, "progs/biggren.mdl");
					}
					else
					{
						if ((self.weapon == BOT_AI_FLEE))
						{
							newmis.touch = FlareGrenadeTouch;
							newmis.think = FlareGrenadeExplode;
							newmis.skin = TF_FLARE_OFF;
							newmis.avelocity = '300 300 300';
							setmodel (newmis, "progs/flare.mdl");
						}
						else
						{
							if ((self.weapon == BOT_AI_BLAST))
							{
								newmis.touch = GasGrenadeTouch;
								newmis.think = GasGrenadeExplode;
								newmis.skin = BOT_AI_FOLLOW;
								newmis.avelocity = '300 300 300';
								setmodel (newmis, "progs/grenade2.mdl");
							}
							else
							{
								if ((self.weapon == BOT_DEFEND))
								{
									newmis.touch = EMPGrenadeTouch;
									newmis.think = EMPGrenadeExplode;
									newmis.skin = BOT_MOVING;
									newmis.avelocity = '300 300 300';
									setmodel (newmis, "progs/grenade2.mdl");
								}
								else
								{
									if ((self.weapon == BOT_AI_FLAGRUN))
									{
										newmis.touch = FlashGrenadeTouch;
										newmis.think = FlashGrenadeExplode;
										newmis.skin = BOT_FIGHTING;
										newmis.avelocity = '300 300 300';
										setmodel (newmis, "progs/hgren2.mdl");
									}
								}
							}
						}
					}
				}
			}
		}
	}
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, user.origin);
	oldself = self;
	self = self.owner;
	self = oldself;
	dremove (self);
};

void () TeamFortress_ThrowGrenade =
{
	if (!(self.tfstate & TF_FLARE_OFF))
	{
		return;
	}
	self.tfstate = (self.tfstate | FL_PARTIALGROUND);
};

float (float pc) IsLegalClass =
{
	local float bit;

	if (((spy_off == TF_FLARE_OFF) && (pc == BOT_DEFEND)))
	{
		return (TF_FLARE_LIT);
	}
	if ((pc == TF_FLARE_OFF))
	{
		bit = TF_FLARE_OFF;
	}
	else
	{
		if ((pc == BOT_FIGHTING))
		{
			bit = BOT_FIGHTING;
		}
		else
		{
			if ((pc == BOT_AI_FOLLOW))
			{
				bit = BOT_MOVING;
			}
			else
			{
				if ((pc == BOT_MOVING))
				{
					bit = BOT_DEFEND;
				}
				else
				{
					if ((pc == BOT_AI_GRAPPLE))
					{
						bit = BOT_RESUPPLYING;
					}
					else
					{
						if ((pc == BOT_AI_FLEE))
						{
							bit = BOT_AVOIDING_HAZARD;
						}
						else
						{
							if ((pc == BOT_AI_BLAST))
							{
								bit = 64;
							}
							else
							{
								if ((pc == BOT_DEFEND))
								{
									bit = FL_ITEM;
								}
								else
								{
									if ((pc == BOT_AI_FLAGRUN))
									{
										bit = FL_ONGROUND;
									}
									else
									{
										if ((pc == BOT_AI_SCOUT))
										{
											bit = 128;
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if (((illegalclasses & bit) || (TeamFortress_TeamGetIllegalClasses (self.team_no) & bit)))
	{
		return (TF_FLARE_LIT);
	}
	return (TF_FLARE_OFF);
};

void (entity p) TeamFortress_SetSpeed =
{
	local string sp;
	local float tf;
	local entity te;

	stuffcmd (p, "cl_movespeedkey 1\n");
	if ((p.tfstate & 65536))
	{
		if ((TF_FLARE_OFF == TF_FLARE_OFF))
		{
			stuffcmd (p, "m_forward 0\n");
			stuffcmd (p, "m_side 0\n");
		}
		p.velocity = '0 0 0';
		stuffcmd (p, "cl_backspeed 0\n");
		stuffcmd (p, "cl_forwardspeed 0\n");
		stuffcmd (p, "cl_sidespeed 0\n");
		return;
	}
	else
	{
		if ((TF_FLARE_OFF == TF_FLARE_OFF))
		{
			stuffcmd (p, "m_forward 1\n");
			stuffcmd (p, "m_side 0.8\n");
		}
	}
	if ((p.playerclass == TF_FLARE_OFF))
	{
		p.maxfbspeed = 500;
		p.maxstrafespeed = 500;
	}
	else
	{
		if ((p.playerclass == BOT_FIGHTING))
		{
			p.maxfbspeed = 300;
			p.maxstrafespeed = 300;
		}
		else
		{
			if ((p.playerclass == BOT_AI_FOLLOW))
			{
				p.maxfbspeed = BOT_IMPULSE;
				p.maxstrafespeed = BOT_IMPULSE;
			}
			else
			{
				if ((p.playerclass == BOT_MOVING))
				{
					p.maxfbspeed = 300;
					p.maxstrafespeed = 300;
				}
				else
				{
					if ((p.playerclass == BOT_AI_GRAPPLE))
					{
						p.maxfbspeed = 300;
						p.maxstrafespeed = 300;
					}
					else
					{
						if ((p.playerclass == BOT_AI_FLEE))
						{
							p.maxfbspeed = BOT_IMPULSE;
							p.maxstrafespeed = 150;
						}
						else
						{
							if ((p.playerclass == BOT_AI_BLAST))
							{
								p.maxfbspeed = 300;
								p.maxstrafespeed = 250;
							}
							else
							{
								if ((p.playerclass == 11))
								{
									p.maxfbspeed = BOT_IMPULSE;
									p.maxstrafespeed = BOT_IMPULSE;
								}
								else
								{
									if ((p.playerclass == BOT_DEFEND))
									{
										p.maxfbspeed = 300;
										p.maxstrafespeed = 250;
									}
									else
									{
										if ((p.playerclass == BOT_AI_FLAGRUN))
										{
											p.maxfbspeed = 300;
											p.maxstrafespeed = 250;
										}
										else
										{
											if ((p.playerclass == TF_FLARE_LIT))
											{
												p.maxfbspeed = 320;
												p.maxstrafespeed = 320;
												return;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	tf = TF_FLARE_LIT;
	te = find (world, classname, "item_tfgoal");
	while (((te != world) && (tf == TF_FLARE_LIT)))
	{
		if ((te.owner == p))
		{
			if ((te.goal_activation & BOT_FIGHTING))
			{
				tf = TF_FLARE_OFF;
				p.maxfbspeed = (p.maxfbspeed / BOT_FIGHTING);
				p.maxstrafespeed = (p.maxstrafespeed / BOT_FIGHTING);
			}
		}
		te = find (te, classname, "item_tfgoal");
	}
	if ((p.tfstate & 32768))
	{
		p.maxfbspeed = ((p.maxfbspeed / BOT_AI_FOLLOW) * BOT_FIGHTING);
		p.maxstrafespeed = ((p.maxstrafespeed / BOT_AI_FOLLOW) * BOT_FIGHTING);
	}
	if (p.leg_damage)
	{
		if ((p.leg_damage > BOT_AI_FLEE))
		{
			p.leg_damage = BOT_AI_FLEE;
		}
		p.maxfbspeed = (p.maxfbspeed * ((BOT_AI_SCOUT - p.leg_damage) / BOT_AI_SCOUT));
		p.maxstrafespeed = ((p.maxstrafespeed * (BOT_AI_SCOUT - p.leg_damage)) / BOT_AI_SCOUT);
	}
	if ((p.tfstate & FL_WATERJUMP))
	{
		if ((p.maxfbspeed > 60))
		{
			p.maxfbspeed = 60;
		}
		if ((p.maxstrafespeed > 60))
		{
			p.maxstrafespeed = 60;
		}
	}
	sp = ftos (p.maxfbspeed);
	stuffcmd (p, "cl_backspeed ");
	stuffcmd (p, sp);
	stuffcmd (p, "\n");
	stuffcmd (p, "cl_forwardspeed ");
	stuffcmd (p, sp);
	stuffcmd (p, "\n");
	sp = ftos (p.maxstrafespeed);
	stuffcmd (p, "cl_sidespeed ");
	stuffcmd (p, sp);
	stuffcmd (p, "\n");
};

void () TeamFortress_SetHealth =
{
	if ((self.playerclass == TF_FLARE_OFF))
	{
		self.max_health = 100;
	}
	else
	{
		if ((self.playerclass == BOT_FIGHTING))
		{
			self.max_health = 90;
		}
		else
		{
			if ((self.playerclass == BOT_AI_FOLLOW))
			{
				self.max_health = 100;
			}
			else
			{
				if ((self.playerclass == BOT_MOVING))
				{
					self.max_health = 90;
				}
				else
				{
					if ((self.playerclass == BOT_AI_GRAPPLE))
					{
						self.max_health = 90;
					}
					else
					{
						if ((self.playerclass == BOT_AI_FLEE))
						{
							self.max_health = 100;
						}
						else
						{
							if ((self.playerclass == BOT_AI_BLAST))
							{
								self.max_health = 100;
							}
							else
							{
								if ((self.playerclass == 11))
								{
									self.max_health = 50;
								}
								else
								{
									if ((self.playerclass == BOT_DEFEND))
									{
										self.max_health = 90;
									}
									else
									{
										if ((self.playerclass == BOT_AI_FLAGRUN))
										{
											self.max_health = 80;
										}
										else
										{
											if ((self.playerclass == TF_FLARE_LIT))
											{
												self.max_health = TF_FLARE_OFF;
												self.takedamage = TF_FLARE_LIT;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	self.health = self.max_health;
};

void (entity p) TeamFortress_SetSkin =
{
	local string st;

	self.immune_to_check = (time + BOT_MOVING);
	if (((p.playerclass == BOT_DEFEND) && (p.undercover_skin != TF_FLARE_LIT)))
	{
		p.skin = p.undercover_skin;
	}
	else
	{
		p.skin = p.playerclass;
	}
	if ((p.skin != TF_FLARE_LIT))
	{
		stuffcmd (p, "skin ");
		if ((p.team_no == BOT_MOVING))
		{
			if ((p.skin == TF_FLARE_OFF))
			{
				stuffcmd (p, "tf_scout\n");
			}
			else
			{
				if ((p.skin == BOT_FIGHTING))
				{
					stuffcmd (p, "tf_snipe\n");
				}
				else
				{
					if ((p.skin == BOT_AI_FOLLOW))
					{
						stuffcmd (p, "tf_sold\n");
					}
					else
					{
						if ((p.skin == BOT_MOVING))
						{
							stuffcmd (p, "tf_demo\n");
						}
						else
						{
							if ((p.skin == BOT_AI_GRAPPLE))
							{
								stuffcmd (p, "tf_medic\n");
							}
							else
							{
								if ((p.skin == BOT_AI_FLEE))
								{
									stuffcmd (p, "tf_hwguy\n");
								}
								else
								{
									if ((p.skin == BOT_AI_BLAST))
									{
										stuffcmd (p, "tf_pyro\n");
									}
									else
									{
										if ((p.skin == BOT_DEFEND))
										{
											stuffcmd (p, "tf_spy\n");
										}
										else
										{
											if ((p.skin == BOT_AI_FLAGRUN))
											{
												stuffcmd (p, "tf_eng\n");
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		else
		{
			if ((p.team_no == BOT_AI_FOLLOW))
			{
				if ((p.skin == TF_FLARE_OFF))
				{
					stuffcmd (p, "tf_scout\n");
				}
				else
				{
					if ((p.skin == BOT_FIGHTING))
					{
						stuffcmd (p, "tf_snipe\n");
					}
					else
					{
						if ((p.skin == BOT_AI_FOLLOW))
						{
							stuffcmd (p, "tf_sold\n");
						}
						else
						{
							if ((p.skin == BOT_MOVING))
							{
								stuffcmd (p, "tf_demo\n");
							}
							else
							{
								if ((p.skin == BOT_AI_GRAPPLE))
								{
									stuffcmd (p, "tf_medic\n");
								}
								else
								{
									if ((p.skin == BOT_AI_FLEE))
									{
										stuffcmd (p, "tf_hwguy\n");
									}
									else
									{
										if ((p.skin == BOT_AI_BLAST))
										{
											stuffcmd (p, "tf_pyro\n");
										}
										else
										{
											if ((p.skin == BOT_DEFEND))
											{
												stuffcmd (p, "tf_spy\n");
											}
											else
											{
												if ((p.skin == BOT_AI_FLAGRUN))
												{
													stuffcmd (p, "tf_eng\n");
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			else
			{
				if ((p.team_no == BOT_FIGHTING))
				{
					if ((p.skin == TF_FLARE_OFF))
					{
						stuffcmd (p, "tf_scout\n");
					}
					else
					{
						if ((p.skin == BOT_FIGHTING))
						{
							stuffcmd (p, "tf_snipe\n");
						}
						else
						{
							if ((p.skin == BOT_AI_FOLLOW))
							{
								stuffcmd (p, "tf_sold\n");
							}
							else
							{
								if ((p.skin == BOT_MOVING))
								{
									stuffcmd (p, "tf_demo\n");
								}
								else
								{
									if ((p.skin == BOT_AI_GRAPPLE))
									{
										stuffcmd (p, "tf_medic\n");
									}
									else
									{
										if ((p.skin == BOT_AI_FLEE))
										{
											stuffcmd (p, "tf_hwguy\n");
										}
										else
										{
											if ((p.skin == BOT_AI_BLAST))
											{
												stuffcmd (p, "tf_pyro\n");
											}
											else
											{
												if ((p.skin == BOT_DEFEND))
												{
													stuffcmd (p, "tf_spy\n");
												}
												else
												{
													if ((p.skin == BOT_AI_FLAGRUN))
													{
														stuffcmd (p, "tf_eng\n");
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				else
				{
					if ((p.skin == TF_FLARE_OFF))
					{
						stuffcmd (p, "tf_scout\n");
					}
					else
					{
						if ((p.skin == BOT_FIGHTING))
						{
							stuffcmd (p, "tf_snipe\n");
						}
						else
						{
							if ((p.skin == BOT_AI_FOLLOW))
							{
								stuffcmd (p, "tf_sold\n");
							}
							else
							{
								if ((p.skin == BOT_MOVING))
								{
									stuffcmd (p, "tf_demo\n");
								}
								else
								{
									if ((p.skin == BOT_AI_GRAPPLE))
									{
										stuffcmd (p, "tf_medic\n");
									}
									else
									{
										if ((p.skin == BOT_AI_FLEE))
										{
											stuffcmd (p, "tf_hwguy\n");
										}
										else
										{
											if ((p.skin == BOT_AI_BLAST))
											{
												stuffcmd (p, "tf_pyro\n");
											}
											else
											{
												if ((p.skin == BOT_DEFEND))
												{
													stuffcmd (p, "tf_spy\n");
												}
												else
												{
													if ((p.skin == BOT_AI_FLAGRUN))
													{
														stuffcmd (p, "tf_eng\n");
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		if ((p.skin == 11))
		{
			stuffcmd (p, "base\n");
		}
	}
	else
	{
		stuffcmd (p, "skin base\n");
	}
};

void () TeamFortress_SetEquipment =
{
	local entity te;
	local string st;
	local float kept_items;

	if ((self.classname != "player"))
	{
		return;
	}
	kept_items = (self.tf_items & (131072 | 262144));
	self.items = TF_FLARE_LIT;
	self.current_weapon = TF_FLARE_LIT;
	self.weapons_carried = TF_FLARE_LIT;
	self.tf_items = TF_FLARE_LIT;
	self.tf_items_flags = TF_FLARE_LIT;
	self.armorclass = TF_FLARE_LIT;
	self.impulse = TF_FLARE_LIT;
	self.undercover_skin = TF_FLARE_LIT;
	if ((self.undercover_team != TF_FLARE_LIT))
	{
		self.immune_to_check = (time + BOT_MOVING);
		self.undercover_team = TF_FLARE_LIT;
		stuffcmd (self, "color ");
		st = ftos ((TeamFortress_TeamGetColor (self.team_no) - TF_FLARE_OFF));
		stuffcmd (self, st);
		stuffcmd (self, "\n");
	}
	self.is_building = TF_FLARE_LIT;
	self.is_detpacking = TF_FLARE_LIT;
	self.is_undercover = TF_FLARE_LIT;
	self.is_feigning = TF_FLARE_LIT;
	self.is_unabletospy = TF_FLARE_LIT;
	self.ammo_medikit = TF_FLARE_LIT;
	self.maxammo_medikit = TF_FLARE_LIT;
	self.ammo_detpack = TF_FLARE_LIT;
	self.maxammo_detpack = TF_FLARE_LIT;
	self.items_allowed = TF_FLARE_LIT;
	self.armor_allowed = TF_FLARE_LIT;
	self.maxarmor = TF_FLARE_LIT;
	self.weaponmode = TF_FLARE_LIT;
	self.respawn_time = TF_FLARE_LIT;
	self.heat = TF_FLARE_LIT;
	self.tfstate = (self.tfstate - (self.tfstate & BOT_FIGHTING));
	if ((self.team_no == TF_FLARE_LIT))
	{
		self.lives = CONTENT_EMPTY;
	}
	self.items = (self.items | kept_items);
	if ((toggleflags & BOT_FIGHTING))
	{
		te = spawn ();
		te.nextthink = (time + BOT_FIGHTING);
		te.think = TeamFortress_CheckforCheats;
		te.owner = self;
		te.classname = "timer";
	}
	if ((self.playerclass == TF_FLARE_OFF))
	{
		self.weapons_carried = (((self.weapons_carried | BOT_RESUPPLYING) | 128) | FL_ONGROUND);
		self.ammo_rockets = TF_FLARE_LIT;
		self.ammo_nails = 100;
		self.ammo_shells = 25;
		self.ammo_cells = 50;
		self.maxammo_rockets = 25;
		self.maxammo_nails = BOT_IMPULSE;
		self.maxammo_shells = 50;
		self.maxammo_cells = 100;
		self.no_grenades_1 = BOT_FIGHTING;
		self.no_grenades_2 = BOT_AI_FOLLOW;
		self.tp_grenades_1 = BOT_AI_FLAGRUN;
		self.tp_grenades_2 = BOT_FIGHTING;
		self.tf_items = TF_FLARE_OFF;
		self.tf_items_flags = (self.tf_items_flags | TF_FLARE_OFF);
		self.armorclass = (self.armorclass | TF_FLARE_LIT);
		self.armortype = 0.3;
		self.armorvalue = 25;
		self.armor_allowed = 0.3;
		self.maxarmor = 50;
		self.current_weapon = FL_ONGROUND;
		self.items_allowed = ((BOT_RESUPPLYING | 128) | FL_ONGROUND);
		self.items = ((self.items | TF_FLARE_OFF) | BOT_MOVING);
	}
	else
	{
		if ((self.playerclass == BOT_FIGHTING))
		{
			self.weapons_carried = ((((self.weapons_carried | BOT_AVOIDING_HAZARD) | 64) | BOT_RESUPPLYING) | FL_ONGROUND);
			self.ammo_rockets = TF_FLARE_LIT;
			self.ammo_nails = 50;
			self.ammo_shells = 60;
			self.ammo_cells = TF_FLARE_LIT;
			self.maxammo_rockets = 25;
			self.maxammo_nails = 100;
			self.maxammo_shells = 75;
			self.maxammo_cells = 50;
			self.no_grenades_1 = BOT_FIGHTING;
			self.no_grenades_2 = BOT_AI_FOLLOW;
			self.tp_grenades_1 = TF_FLARE_OFF;
			self.tp_grenades_2 = BOT_AI_FLEE;
			self.tf_items = TF_FLARE_LIT;
			self.armorclass = (self.armorclass | TF_FLARE_LIT);
			self.armortype = 0.3;
			self.armorvalue = TF_FLARE_LIT;
			self.armor_allowed = 0.3;
			self.maxarmor = 50;
			self.current_weapon = BOT_AVOIDING_HAZARD;
			self.items_allowed = (((BOT_AVOIDING_HAZARD | 64) | BOT_RESUPPLYING) | FL_ONGROUND);
			self.items = (((self.items | TF_FLARE_OFF) | BOT_FIGHTING) | BOT_MOVING);
		}
		else
		{
			if ((self.playerclass == BOT_AI_FOLLOW))
			{
				self.weapons_carried = ((((self.weapons_carried | BOT_RESUPPLYING) | 128) | FL_ITEM) | 8192);
				self.ammo_rockets = BOT_AI_SCOUT;
				self.ammo_nails = TF_FLARE_LIT;
				self.ammo_shells = 50;
				self.ammo_cells = TF_FLARE_LIT;
				self.maxammo_rockets = 50;
				self.maxammo_nails = 100;
				self.maxammo_shells = 100;
				self.maxammo_cells = 50;
				self.no_grenades_1 = BOT_MOVING;
				self.no_grenades_2 = TF_FLARE_OFF;
				self.tp_grenades_1 = TF_FLARE_OFF;
				self.tp_grenades_2 = BOT_AI_FOLLOW;
				self.tf_items = TF_FLARE_LIT;
				self.armorclass = (self.armorclass | TF_FLARE_LIT);
				self.armortype = 0.8;
				self.armorvalue = 100;
				self.armor_allowed = 0.8;
				self.maxarmor = BOT_IMPULSE;
				self.current_weapon = 8192;
				self.items_allowed = (((BOT_RESUPPLYING | 128) | FL_ITEM) | 8192);
				self.items = (((self.items | TF_FLARE_OFF) | BOT_FIGHTING) | BOT_AVOIDING_HAZARD);
			}
			else
			{
				if ((self.playerclass == BOT_MOVING))
				{
					self.weapons_carried = ((((self.weapons_carried | BOT_RESUPPLYING) | 128) | FL_WATERJUMP) | 131072);
					self.ammo_rockets = 20;
					self.ammo_nails = TF_FLARE_LIT;
					self.ammo_shells = 30;
					self.ammo_cells = TF_FLARE_LIT;
					self.maxammo_rockets = 50;
					self.maxammo_nails = 50;
					self.maxammo_shells = 75;
					self.maxammo_cells = 50;
					self.no_grenades_1 = BOT_MOVING;
					self.no_grenades_2 = BOT_MOVING;
					self.tp_grenades_1 = TF_FLARE_OFF;
					self.tp_grenades_2 = BOT_MOVING;
					self.tf_items = TF_FLARE_LIT;
					self.ammo_detpack = TF_FLARE_OFF;
					self.maxammo_detpack = TF_FLARE_OFF;
					self.armorclass = (self.armorclass | BOT_MOVING);
					self.armortype = 0.6;
					self.armorvalue = 50;
					self.armor_allowed = 0.6;
					self.maxarmor = 100;
					self.current_weapon = FL_WATERJUMP;
					self.items_allowed = (((BOT_RESUPPLYING | 128) | FL_WATERJUMP) | 131072);
					self.items = ((self.items | TF_FLARE_OFF) | BOT_RESUPPLYING);
				}
				else
				{
					if ((self.playerclass == BOT_AI_GRAPPLE))
					{
						self.weapons_carried = (((((self.weapons_carried | BOT_FIGHTING) | BOT_MOVING) | 128) | FL_ITEM) | FL_PARTIALGROUND);
						self.ammo_rockets = TF_FLARE_LIT;
						self.ammo_nails = 50;
						self.ammo_shells = 50;
						self.ammo_cells = TF_FLARE_LIT;
						self.maxammo_rockets = 25;
						self.maxammo_nails = 150;
						self.maxammo_shells = 75;
						self.maxammo_cells = 50;
						self.no_grenades_1 = BOT_AI_FOLLOW;
						self.no_grenades_2 = BOT_FIGHTING;
						self.tp_grenades_1 = TF_FLARE_OFF;
						self.tp_grenades_2 = BOT_FIGHTING;
						self.tf_items = TF_FLARE_LIT;
						self.armorclass = (self.armorclass | TF_FLARE_LIT);
						self.armortype = 0.3;
						self.armorvalue = 50;
						self.armor_allowed = 0.6;
						self.maxarmor = 100;
						self.current_weapon = FL_PARTIALGROUND;
						self.ammo_medikit = 50;
						self.maxammo_medikit = 100;
						te = spawn ();
						te.nextthink = (time + BOT_AI_FOLLOW);
						te.think = TeamFortress_Regenerate;
						te.owner = self;
						te.classname = "timer";
						self.items_allowed = ((((BOT_FIGHTING | BOT_MOVING) | 128) | FL_ITEM) | FL_PARTIALGROUND);
						self.items = (((self.items | TF_FLARE_OFF) | BOT_FIGHTING) | BOT_DEFEND);
					}
					else
					{
						if ((self.playerclass == BOT_AI_FLEE))
						{
							self.weapons_carried = ((((self.weapons_carried | 32768) | BOT_RESUPPLYING) | 128) | FL_ITEM);
							self.ammo_rockets = TF_FLARE_LIT;
							self.ammo_nails = TF_FLARE_LIT;
							self.ammo_shells = BOT_IMPULSE;
							self.ammo_cells = 24;
							self.maxammo_rockets = 25;
							self.maxammo_nails = BOT_IMPULSE;
							self.maxammo_shells = BOT_IMPULSE;
							self.maxammo_cells = 50;
							self.no_grenades_1 = BOT_MOVING;
							self.no_grenades_2 = TF_FLARE_OFF;
							self.tp_grenades_1 = TF_FLARE_OFF;
							self.tp_grenades_2 = BOT_MOVING;
							self.tf_items = TF_FLARE_LIT;
							self.armorclass = (self.armorclass | TF_FLARE_LIT);
							self.armortype = 0.8;
							self.armorvalue = 150;
							self.armor_allowed = 0.8;
							self.maxarmor = 250;
							self.current_weapon = FL_ITEM;
							self.items_allowed = (((32768 | BOT_RESUPPLYING) | 128) | FL_ITEM);
							self.items = (((self.items | TF_FLARE_OFF) | BOT_FIGHTING) | BOT_AVOIDING_HAZARD);
						}
						else
						{
							if ((self.playerclass == BOT_AI_BLAST))
							{
								self.weapons_carried = ((((self.weapons_carried | 16384) | 4096) | BOT_RESUPPLYING) | 128);
								self.ammo_rockets = 15;
								self.ammo_nails = TF_FLARE_LIT;
								self.ammo_shells = 20;
								self.ammo_cells = 120;
								self.maxammo_rockets = 60;
								self.maxammo_nails = 50;
								self.maxammo_shells = 40;
								self.maxammo_cells = BOT_IMPULSE;
								self.no_grenades_1 = TF_FLARE_OFF;
								self.no_grenades_2 = BOT_MOVING;
								self.tp_grenades_1 = TF_FLARE_OFF;
								self.tp_grenades_2 = BOT_AI_GRAPPLE;
								self.tf_items = TF_FLARE_LIT;
								self.armorclass = (self.armorclass | BOT_RESUPPLYING);
								self.armortype = 0.6;
								self.armorvalue = 50;
								self.armor_allowed = 0.6;
								self.maxarmor = 150;
								self.current_weapon = 4096;
								self.items_allowed = (((16384 | 4096) | BOT_RESUPPLYING) | 128);
								self.items = (((self.items | TF_FLARE_OFF) | BOT_RESUPPLYING) | BOT_AVOIDING_HAZARD);
							}
							else
							{
								if ((self.playerclass == 11))
								{
									self.weapons_carried = (self.weapons_carried | BOT_RESUPPLYING);
									self.ammo_rockets = TF_FLARE_LIT;
									self.ammo_nails = TF_FLARE_LIT;
									self.ammo_shells = TF_FLARE_LIT;
									self.ammo_cells = TF_FLARE_LIT;
									self.maxammo_rockets = TF_FLARE_LIT;
									self.maxammo_nails = TF_FLARE_LIT;
									self.maxammo_shells = TF_FLARE_LIT;
									self.maxammo_cells = TF_FLARE_LIT;
									self.no_grenades_1 = TF_FLARE_LIT;
									self.no_grenades_2 = TF_FLARE_LIT;
									self.tp_grenades_1 = TF_FLARE_LIT;
									self.tp_grenades_2 = TF_FLARE_LIT;
									self.tf_items = TF_FLARE_LIT;
									self.armorclass = (self.armorclass | TF_FLARE_LIT);
									self.armortype = TF_FLARE_LIT;
									self.armorvalue = TF_FLARE_LIT;
									self.armor_allowed = TF_FLARE_LIT;
									self.maxarmor = TF_FLARE_LIT;
									self.current_weapon = BOT_RESUPPLYING;
									self.items_allowed = BOT_RESUPPLYING;
									self.items = TF_FLARE_LIT;
								}
								else
								{
									if ((self.playerclass == BOT_DEFEND))
									{
										self.weapons_carried = ((((self.weapons_carried | BOT_RESUPPLYING) | 262144) | FL_ITEM) | FL_ONGROUND);
										self.ammo_rockets = TF_FLARE_LIT;
										self.ammo_nails = TF_FLARE_LIT;
										self.ammo_shells = 40;
										self.ammo_cells = BOT_AI_SCOUT;
										self.maxammo_rockets = 15;
										self.maxammo_nails = 50;
										self.maxammo_shells = 40;
										self.maxammo_cells = 30;
										self.no_grenades_1 = BOT_FIGHTING;
										self.no_grenades_2 = BOT_FIGHTING;
										self.tp_grenades_1 = TF_FLARE_OFF;
										self.tp_grenades_2 = BOT_AI_BLAST;
										self.tf_items = TF_FLARE_LIT;
										self.armorclass = (self.armorclass | TF_FLARE_LIT);
										self.armortype = 0.3;
										self.armorvalue = 25;
										self.armor_allowed = 0.3;
										self.maxarmor = 100;
										self.current_weapon = 262144;
										self.items_allowed = (((BOT_RESUPPLYING | 262144) | FL_ITEM) | FL_ONGROUND);
										self.items = (((self.items | TF_FLARE_OFF) | BOT_FIGHTING) | BOT_MOVING);
										if ((invis_only == TF_FLARE_OFF))
										{
											te = spawn ();
											te.nextthink = (time + BOT_AI_GRAPPLE);
											te.think = TeamFortress_RegenerateCells;
											te.owner = self;
											te.classname = "timer";
										}
									}
									else
									{
										if ((self.playerclass == BOT_AI_FLAGRUN))
										{
											self.weapons_carried = (((self.weapons_carried | BOT_DEFEND) | IT_INVISIBILITY) | FL_ITEM);
											self.ammo_rockets = TF_FLARE_LIT;
											self.ammo_nails = 25;
											self.ammo_shells = 20;
											self.ammo_cells = 100;
											self.maxammo_rockets = 30;
											self.maxammo_nails = 50;
											self.maxammo_shells = 50;
											self.maxammo_cells = BOT_IMPULSE;
											self.no_grenades_1 = BOT_FIGHTING;
											self.no_grenades_2 = BOT_FIGHTING;
											self.tp_grenades_1 = TF_FLARE_OFF;
											self.tp_grenades_2 = BOT_DEFEND;
											self.tf_items = TF_FLARE_LIT;
											self.armorclass = (self.armorclass | TF_FLARE_LIT);
											self.armortype = 0.3;
											self.armorvalue = 25;
											self.armor_allowed = 0.6;
											self.maxarmor = 50;
											self.current_weapon = IT_INVISIBILITY;
											self.items_allowed = ((BOT_DEFEND | IT_INVISIBILITY) | FL_ITEM);
											self.items = ((self.items | TF_FLARE_OFF) | BOT_FIGHTING);
										}
										else
										{
											if ((self.playerclass == TF_FLARE_LIT))
											{
												self.items = TF_FLARE_LIT;
												self.ammo_rockets = TF_FLARE_LIT;
												self.ammo_nails = TF_FLARE_LIT;
												self.ammo_shells = TF_FLARE_LIT;
												self.ammo_cells = TF_FLARE_LIT;
												self.no_grenades_1 = TF_FLARE_LIT;
												self.no_grenades_2 = TF_FLARE_LIT;
												self.tp_grenades_1 = TF_FLARE_LIT;
												self.tp_grenades_2 = TF_FLARE_LIT;
												self.armorclass = TF_FLARE_LIT;
												self.armortype = TF_FLARE_LIT;
												self.armorvalue = TF_FLARE_LIT;
												self.weapon = TF_FLARE_LIT;
												self.current_weapon = TF_FLARE_LIT;
												self.weapons_carried = TF_FLARE_LIT;
												self.flags = (BOT_DEFEND | 128);
												self.waterlevel = BOT_AI_FOLLOW;
												self.takedamage = TF_FLARE_LIT;
												self.solid = TF_FLARE_LIT;
												self.movetype = BOT_DEFEND;
												self.model = string_null;
												self.mdl = string_null;
												self.modelindex = TF_FLARE_LIT;
												self.weaponmodel = string_null;
												modelindex_player = TF_FLARE_LIT;
												self.tfstate = (self.tfstate | BOT_FIGHTING);
												setmodel (self, string_null);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	if ((self.armortype >= 0.8))
	{
		self.items = (self.items | 32768);
	}
	else
	{
		if ((self.armortype >= 0.6))
		{
			self.items = (self.items | 16384);
		}
		else
		{
			if ((self.armortype >= 0.3))
			{
				self.items = (self.items | 8192);
			}
		}
	}
	if ((allow_hook && (self.playerclass != TF_FLARE_LIT)))
	{
		self.weapons_carried = (self.weapons_carried | TF_FLARE_OFF);
	}
	W_SetCurrentAmmo ();
};

float (entity Retriever, float AmmoType) TeamFortress_GetMaxAmmo =
{
	if ((AmmoType == FL_ITEM))
	{
		return (Retriever.maxammo_shells);
	}
	else
	{
		if ((AmmoType == FL_ONGROUND))
		{
			return (Retriever.maxammo_nails);
		}
		else
		{
			if ((AmmoType == FL_WATERJUMP))
			{
				return (Retriever.maxammo_cells);
			}
			else
			{
				if ((AmmoType == FL_PARTIALGROUND))
				{
					return (Retriever.maxammo_rockets);
				}
				else
				{
					if ((AmmoType == BOT_MOVING))
					{
						return (Retriever.maxammo_medikit);
					}
					else
					{
						if ((AmmoType == 131072))
						{
							return (Retriever.maxammo_detpack);
						}
					}
				}
			}
		}
	}
	dprint ("Error in TeamFortress_GetMaxAmmo()\n");
	dprint ("Invalid ammo type passed.\n");
	return (TF_FLARE_LIT);
};

float (entity Retriever, float WeaponType) TeamFortress_CanGetWeapon =
{
	if ((Retriever.items_allowed & WeaponType))
	{
		return (TF_FLARE_OFF);
	}
	return (TF_FLARE_LIT);
};

void (entity Player, float Armorclass) TeamFortress_DescribeArmor =
{
	local string st;

	if ((Armorclass == TF_FLARE_LIT))
	{
		return;
	}
	if ((Armorclass & BOT_RESUPPLYING))
	{
		sprint (Player, BOT_FIGHTING, "Asbestos ");
	}
	if ((Armorclass & BOT_FIGHTING))
	{
		sprint (Player, BOT_FIGHTING, "Wooden ");
	}
	if ((Armorclass & BOT_MOVING))
	{
		sprint (Player, BOT_FIGHTING, "Blast ");
	}
	if ((Armorclass & BOT_DEFEND))
	{
		sprint (Player, BOT_FIGHTING, "Shockproof ");
	}
	if ((Armorclass & TF_FLARE_OFF))
	{
		sprint (Player, BOT_FIGHTING, "Kevlar ");
	}
	sprint (Player, BOT_FIGHTING, "armor\n");
};

void (entity Retriever, entity Items) TeamFortress_AddBackpackItems =
{
	return;
};

string (float pc) TeamFortress_GetClassName =
{
	if ((pc == TF_FLARE_OFF))
	{
		return ("Scout");
	}
	else
	{
		if ((pc == BOT_FIGHTING))
		{
			return ("Sniper");
		}
		else
		{
			if ((pc == BOT_AI_FOLLOW))
			{
				return ("Soldier");
			}
			else
			{
				if ((pc == BOT_MOVING))
				{
					return ("Demolitions Man");
				}
				else
				{
					if ((pc == BOT_AI_GRAPPLE))
					{
						return ("Combat Medic");
					}
					else
					{
						if ((pc == BOT_AI_FLEE))
						{
							return ("Heavy Weapons Guy");
						}
						else
						{
							if ((pc == BOT_AI_BLAST))
							{
								return ("Pyro");
							}
							else
							{
								if ((pc == BOT_DEFEND))
								{
									return ("Spy");
								}
								else
								{
									if ((pc == BOT_AI_FLAGRUN))
									{
										return ("Engineer");
									}
									else
									{
										if ((pc == 11))
										{
											return ("Civilian");
										}
										else
										{
											if ((pc == TF_FLARE_LIT))
											{
												return ("Observer");
											}
											else
											{
												if ((pc == BOT_AI_SCOUT))
												{
													return ("Random Playerclass");
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
};

void (entity Viewer, float pc, float rpc) TeamFortress_PrintClassName =
{
	local string st;

	st = TeamFortress_GetClassName (pc);
	sprint (Viewer, BOT_FIGHTING, st);
	if ((rpc != TF_FLARE_LIT))
	{
		sprint (Viewer, BOT_FIGHTING, " (Random)");
	}
	sprint (Viewer, BOT_FIGHTING, "\n");
};

void () TeamFortress_RemoveTimers =
{
	local entity te;

	self.leg_damage = TF_FLARE_LIT;
	self.is_undercover = TF_FLARE_LIT;
	self.is_building = TF_FLARE_LIT;
	self.building = world;
	if ((self.tfstate & FL_WATERJUMP))
	{
		self.tfstate = (self.tfstate - FL_WATERJUMP);
		TeamFortress_SetSpeed (self);
		self.heat = TF_FLARE_LIT;
	}
	te = find (world, classname, "timer");
	while ((te != world))
	{
		if ((te.owner == self))
		{
			dremove (te);
			te = find (world, classname, "timer");
		}
		else
		{
			te = find (te, classname, "timer");
		}
	}
	te = find (world, classname, "item_tfgoal");
	while (te)
	{
		if ((te.owner == self))
		{
			if (!(te.goal_activation & FL_ITEM))
			{
				tfgoalitem_RemoveFromPlayer (te, self, TF_FLARE_LIT);
			}
			if (((CTF_Map == TF_FLARE_OFF) && (te.goal_no == TF_FLARE_OFF)))
			{
				bprint (BOT_FIGHTING, self.netname);
				bprint (BOT_FIGHTING, "  the  flag!\n");
			}
			else
			{
				if (((CTF_Map == TF_FLARE_OFF) && (te.goal_no == BOT_FIGHTING)))
				{
					bprint (BOT_FIGHTING, self.netname);
					bprint (BOT_FIGHTING, "  the  flag!\n");
				}
			}
		}
		te = find (te, classname, "item_tfgoal");
	}
	te = find (world, classname, "detpack");
	while (te)
	{
		if (((te.weaponmode == TF_FLARE_OFF) && (te.enemy == self)))
		{
			te.weaponmode = TF_FLARE_LIT;
		}
		te = find (te, classname, "detpack");
	}
	TeamFortress_DetonatePipebombs ();
	stuffcmd (self, "v_idlescale 0\n");
	stuffcmd (self, "v_cshift 0 0 0 0\n");
	self.item_list = TF_FLARE_LIT;
	self.FlashTime = TF_FLARE_LIT;
	CenterPrint (self, "\n");
	self.menu_count = 25;
	self.current_menu = TF_FLARE_OFF;
	self.impulse = TF_FLARE_LIT;
};

void (float Suicided) TeamFortress_SetupRespawn =
{
	local float restime;
	local string db;

	if ((self.respawn_time > time))
	{
		return;
	}
	if ((toggleflags & BOT_MOVING))
	{
		restime = respawn_delay_time;
	}
	else
	{
		restime = TF_FLARE_LIT;
	}
	if (Suicided)
	{
		if ((self.lives > TF_FLARE_LIT))
		{
			self.lives = (self.lives - TF_FLARE_OFF);
		}
		restime = (restime + BOT_AI_GRAPPLE);
	}
	if ((self.lives > TF_FLARE_LIT))
	{
		self.lives = (self.lives - TF_FLARE_OFF);
	}
	if ((self.lives != CONTENT_EMPTY))
	{
		if ((self.lives == TF_FLARE_LIT))
		{
			sprint (self, BOT_FIGHTING, "NO lives left, returning to Observer mode.\n");
			self.playerclass = TF_FLARE_LIT;
			self.tfstate = (self.tfstate - (self.tfstate & BOT_DEFEND));
			self.movetype = BOT_DEFEND;
			self.solid = TF_FLARE_LIT;
			self.model = "";
			self.mdl = "";
			self.velocity = '0 0 0';
			self.avelocity = '0 0 0';
			self.enemy = world;
			setmodel (self, "");
			return;
		}
		if ((self.lives == TF_FLARE_OFF))
		{
			sprint (self, BOT_FIGHTING, "LAST life.\n");
		}
		else
		{
			db = ftos (self.lives);
			sprint (self, BOT_FIGHTING, db);
			sprint (self, BOT_FIGHTING, " lives left.\n");
		}
	}
	self.respawn_time = (time + restime);
	if ((restime > BOT_AI_FOLLOW))
	{
		db = ftos (restime);
		sprint (self, BOT_FIGHTING, db);
		sprint (self, BOT_FIGHTING, " seconds till respawn.\n");
	}
};

void () TeamFortress_CheckClassStats =
{
	if ((self.armortype > self.armor_allowed))
	{
		self.armortype = self.armor_allowed;
	}
	if ((self.armorvalue > self.maxarmor))
	{
		self.armorvalue = self.maxarmor;
	}
	if ((self.armortype < TF_FLARE_LIT))
	{
		self.armortype = TF_FLARE_LIT;
	}
	if ((self.armorvalue < TF_FLARE_LIT))
	{
		self.armorvalue = TF_FLARE_LIT;
	}
	if ((self.ammo_shells > TeamFortress_GetMaxAmmo (self, FL_ITEM)))
	{
		self.ammo_shells = TeamFortress_GetMaxAmmo (self, FL_ITEM);
	}
	if ((self.ammo_shells < TF_FLARE_LIT))
	{
		self.ammo_shells = TF_FLARE_LIT;
	}
	if ((self.ammo_nails > TeamFortress_GetMaxAmmo (self, FL_ONGROUND)))
	{
		self.ammo_nails = TeamFortress_GetMaxAmmo (self, FL_ONGROUND);
	}
	if ((self.ammo_nails < TF_FLARE_LIT))
	{
		self.ammo_nails = TF_FLARE_LIT;
	}
	if ((self.ammo_rockets > TeamFortress_GetMaxAmmo (self, FL_PARTIALGROUND)))
	{
		self.ammo_rockets = TeamFortress_GetMaxAmmo (self, FL_PARTIALGROUND);
	}
	if ((self.ammo_rockets < TF_FLARE_LIT))
	{
		self.ammo_rockets = TF_FLARE_LIT;
	}
	if ((self.ammo_cells > TeamFortress_GetMaxAmmo (self, FL_WATERJUMP)))
	{
		self.ammo_cells = TeamFortress_GetMaxAmmo (self, FL_WATERJUMP);
	}
	if ((self.ammo_cells < TF_FLARE_LIT))
	{
		self.ammo_cells = TF_FLARE_LIT;
	}
	if ((self.ammo_medikit > TeamFortress_GetMaxAmmo (self, BOT_MOVING)))
	{
		self.ammo_medikit = TeamFortress_GetMaxAmmo (self, BOT_MOVING);
	}
	if ((self.ammo_medikit < TF_FLARE_LIT))
	{
		self.ammo_medikit = TF_FLARE_LIT;
	}
	if ((self.ammo_detpack > TeamFortress_GetMaxAmmo (self, 131072)))
	{
		self.ammo_detpack = TeamFortress_GetMaxAmmo (self, 131072);
	}
	if ((self.ammo_detpack < TF_FLARE_LIT))
	{
		self.ammo_detpack = TF_FLARE_LIT;
	}
	if ((self.no_grenades_1 < TF_FLARE_LIT))
	{
		self.no_grenades_1 = TF_FLARE_LIT;
	}
	if ((self.no_grenades_2 < TF_FLARE_LIT))
	{
		self.no_grenades_2 = TF_FLARE_LIT;
	}
	if (((self.health > self.max_health) && !(self.items & 65536)))
	{
		TF_T_Damage (self, world, world, (self.max_health - self.health), TF_FLARE_LIT, FL_ITEM);
	}
	if ((self.health < TF_FLARE_LIT))
	{
		T_Heal (self, (self.health - self.health), TF_FLARE_LIT);
	}
	self.items = (self.items - (self.items & ((8192 | 16384) | 32768)));
	if ((self.armortype >= 0.8))
	{
		self.items = (self.items | 32768);
	}
	else
	{
		if ((self.armortype >= 0.6))
		{
			self.items = (self.items | 16384);
		}
		else
		{
			if ((self.armortype >= 0.3))
			{
				self.items = (self.items | 8192);
			}
		}
	}
};

void (float type) TeamFortress_DropAmmo =
{
	local float ammo;

	if ((type == TF_FLARE_OFF))
	{
		ammo = 20;
		if ((self.ammo_shells < ammo))
		{
			if ((self.playerclass == BOT_AI_FLAGRUN))
			{
				if (((self.ammo_cells / BOT_AI_FOLLOW) > (ammo - self.ammo_shells)))
				{
					sprint (self, BOT_FIGHTING, "you make some shells.\n");
					self.ammo_cells = (self.ammo_cells - ((ammo - self.ammo_shells) * BOT_AI_FOLLOW));
					self.ammo_shells = ammo;
				}
			}
			if ((self.ammo_shells < ammo))
			{
				return;
			}
		}
		self.ammo_shells = (self.ammo_shells - ammo);
	}
	else
	{
		if ((type == BOT_FIGHTING))
		{
			ammo = 20;
			if ((self.ammo_nails < ammo))
			{
				if ((self.playerclass == BOT_AI_FLAGRUN))
				{
					if (((self.ammo_cells / BOT_FIGHTING) > (ammo - self.ammo_nails)))
					{
						sprint (self, BOT_FIGHTING, "you make some nails.\n");
						self.ammo_cells = (self.ammo_cells - ((ammo - self.ammo_nails) * BOT_FIGHTING));
						self.ammo_nails = ammo;
					}
				}
				if ((self.ammo_nails < ammo))
				{
					return;
				}
			}
			self.ammo_nails = (self.ammo_nails - ammo);
		}
		else
		{
			if ((type == BOT_AI_FOLLOW))
			{
				ammo = BOT_AI_SCOUT;
				if ((self.ammo_rockets < ammo))
				{
					if ((self.playerclass == BOT_AI_FLAGRUN))
					{
						if (((self.ammo_cells / BOT_AI_GRAPPLE) > (ammo - self.ammo_rockets)))
						{
							sprint (self, BOT_FIGHTING, "you make some rockets.\n");
							self.ammo_cells = (self.ammo_cells - ((ammo - self.ammo_rockets) * BOT_AI_GRAPPLE));
							self.ammo_rockets = ammo;
						}
					}
					if ((self.ammo_rockets < ammo))
					{
						return;
					}
				}
				self.ammo_rockets = (self.ammo_rockets - ammo);
			}
			else
			{
				if ((type == BOT_MOVING))
				{
					ammo = BOT_AI_SCOUT;
					if ((self.ammo_cells < ammo))
					{
						if ((self.playerclass == BOT_AI_FLAGRUN))
						{
							if (((self.ammo_cells / BOT_AI_GRAPPLE) > (ammo - self.ammo_cells)))
							{
								sprint (self, BOT_FIGHTING, "you make some cells.\n");
								self.ammo_cells = (self.ammo_cells - ((ammo - self.ammo_cells) * BOT_AI_GRAPPLE));
								self.ammo_cells = ammo;
							}
						}
						if ((self.ammo_cells < ammo))
						{
							return;
						}
					}
					self.ammo_cells = (self.ammo_cells - ammo);
				}
			}
		}
	}
	W_SetCurrentAmmo ();
	if ((self.team_no != TF_FLARE_LIT))
	{
		increment_team_ammoboxes (self.team_no);
		if ((num_team_ammoboxes (self.team_no) > (20 / number_of_teams)))
		{
			RemoveOldAmmobox (self.team_no);
		}
	}
	else
	{
		num_world_ammoboxes = (num_world_ammoboxes + TF_FLARE_OFF);
		if ((num_world_ammoboxes > 20))
		{
			RemoveOldAmmobox (TF_FLARE_LIT);
		}
	}
	newmis = spawn ();
	newmis.aflag = ammo;
	newmis.weapon = type;
	if ((newmis.weapon == TF_FLARE_OFF))
	{
		newmis.ammo_shells = ammo;
	}
	else
	{
		if ((newmis.weapon == BOT_FIGHTING))
		{
			newmis.ammo_nails = ammo;
		}
		else
		{
			if ((newmis.weapon == BOT_AI_FOLLOW))
			{
				newmis.ammo_rockets = ammo;
			}
			else
			{
				if ((newmis.weapon == BOT_MOVING))
				{
					newmis.ammo_cells = ammo;
				}
			}
		}
	}
	newmis.enemy = self;
	newmis.health = time;
	newmis.movetype = BOT_AI_FLEE;
	newmis.solid = TF_FLARE_OFF;
	newmis.classname = "ammobox";
	newmis.team_no = self.team_no;
	makevectors (self.v_angle);
	if (self.v_angle_x)
	{
		newmis.velocity = ((v_forward * 400) + (v_up * BOT_IMPULSE));
	}
	else
	{
		newmis.velocity = aim (self, 10000);
		newmis.velocity = (newmis.velocity * 400);
		newmis.velocity_z = BOT_IMPULSE;
	}
	newmis.avelocity = '0 300 0';
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, self.origin);
	newmis.nextthink = (time + 30);
	newmis.think = SUB_Remove;
	newmis.touch = TeamFortress_AmmoboxTouch;
	newmis.skin = (type - TF_FLARE_OFF);
	setmodel (newmis, "progs/ammobox.mdl");
};

void () TeamFortress_AmmoboxTouch =
{
	local float took;
	local string quantity;

	took = TF_FLARE_LIT;
	if (((other == self.enemy) && (time < (self.health + BOT_FIGHTING))))
	{
		return;
	}
	if ((other.classname != "player"))
	{
		return;
	}
	if ((other.health <= TF_FLARE_LIT))
	{
		return;
	}
	num_world_ammoboxes = (num_world_ammoboxes - TF_FLARE_OFF);
	decrement_team_ammoboxes (self.team_no);
	if ((self.weapon == TF_FLARE_LIT))
	{
		sprint (other, TF_FLARE_LIT, "You got ");
		if ((self.ammo_shells > TF_FLARE_LIT))
		{
			other.ammo_shells = (other.ammo_shells + self.ammo_shells);
			quantity = ftos (self.ammo_shells);
			sprint2 (other, TF_FLARE_LIT, quantity, " shells  ");
		}
		if ((self.ammo_nails > TF_FLARE_LIT))
		{
			other.ammo_nails = (other.ammo_nails + self.ammo_nails);
			quantity = ftos (self.ammo_nails);
			sprint2 (other, TF_FLARE_LIT, quantity, " nails  ");
		}
		if ((self.ammo_rockets > TF_FLARE_LIT))
		{
			other.ammo_rockets = (other.ammo_rockets + self.ammo_rockets);
			quantity = ftos (self.ammo_rockets);
			sprint2 (other, TF_FLARE_LIT, quantity, " rockets  ");
		}
		if ((self.ammo_cells > TF_FLARE_LIT))
		{
			other.ammo_cells = (other.ammo_cells + self.ammo_cells);
			quantity = ftos (self.ammo_cells);
			sprint2 (other, TF_FLARE_LIT, quantity, " cells  ");
		}
		sprint (other, TF_FLARE_LIT, "\n");
	}
	else
	{
		if ((self.weapon == TF_FLARE_OFF))
		{
			if ((other.ammo_shells >= TeamFortress_GetMaxAmmo (other, FL_ITEM)))
			{
				return;
			}
			other.ammo_shells = (other.ammo_shells + self.aflag);
			self.netname = "shells";
		}
		else
		{
			if ((self.weapon == BOT_FIGHTING))
			{
				if ((other.ammo_nails >= TeamFortress_GetMaxAmmo (other, FL_ONGROUND)))
				{
					return;
				}
				other.ammo_nails = (other.ammo_nails + self.aflag);
				self.netname = "nails";
			}
			else
			{
				if ((self.weapon == BOT_AI_FOLLOW))
				{
					if ((other.ammo_rockets >= TeamFortress_GetMaxAmmo (other, FL_PARTIALGROUND)))
					{
						return;
					}
					other.ammo_rockets = (other.ammo_rockets + self.aflag);
					self.netname = "rockets";
				}
				else
				{
					if ((self.weapon == BOT_MOVING))
					{
						if ((other.ammo_cells >= TeamFortress_GetMaxAmmo (other, FL_WATERJUMP)))
						{
							return;
						}
						other.ammo_cells = (other.ammo_cells + self.aflag);
						self.netname = "cells";
					}
				}
			}
		}
	}
	bound_other_ammo (other);
	if ((self.weapon > TF_FLARE_LIT))
	{
		quantity = ftos (self.aflag);
		sprint5 (other, TF_FLARE_LIT, "You picked up ", quantity, " ", self.netname, "\n");
	}
	sound (other, BOT_AI_FOLLOW, "weapons/lock4.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	stuffcmd (other, "bf\n");
	dremove (self);
	self = other;
	W_SetCurrentAmmo ();
};

float (float tno) num_team_ammoboxes =
{
	if ((tno == TF_FLARE_OFF))
	{
		return (num_team_ammoboxes_1);
	}
	else
	{
		if ((tno == BOT_FIGHTING))
		{
			return (num_team_ammoboxes_2);
		}
		else
		{
			if ((tno == BOT_AI_FOLLOW))
			{
				return (num_team_ammoboxes_3);
			}
			else
			{
				if ((tno == BOT_MOVING))
				{
					return (num_team_ammoboxes_4);
				}
			}
		}
	}
	return (TF_FLARE_LIT);
};

void (float tno) RemoveOldAmmobox =
{
	local float index;

	if ((tno != TF_FLARE_LIT))
	{
		index = num_team_ammoboxes (tno);
		index = (index - (20 / number_of_teams));
	}
	else
	{
		index = (num_world_ammoboxes - 20);
	}
	old = find (world, classname, "ammobox");
	while ((index > TF_FLARE_LIT))
	{
		if ((old == world))
		{
			dprint ("*** ERROR: RemoveOldAmmobox. ***\n");
			dprint ("*** Please report this.        ***\n");
			return;
		}
		if (((old.team_no == tno) || (tno == TF_FLARE_LIT)))
		{
			old.think = SUB_Remove;
			old.nextthink = (time + 0.1);
			index = (index - TF_FLARE_OFF);
			num_world_ammoboxes = (num_world_ammoboxes - TF_FLARE_OFF);
			decrement_team_ammoboxes (old.team_no);
		}
		old = find (old, classname, "ammobox");
	}
};

void (float tno) increment_team_ammoboxes =
{
	if ((tno == TF_FLARE_OFF))
	{
		num_team_ammoboxes_1 = (num_team_ammoboxes_1 + TF_FLARE_OFF);
	}
	else
	{
		if ((tno == BOT_FIGHTING))
		{
			num_team_ammoboxes_2 = (num_team_ammoboxes_2 + TF_FLARE_OFF);
		}
		else
		{
			if ((tno == BOT_AI_FOLLOW))
			{
				num_team_ammoboxes_3 = (num_team_ammoboxes_3 + TF_FLARE_OFF);
			}
			else
			{
				if ((tno == BOT_MOVING))
				{
					num_team_ammoboxes_4 = (num_team_ammoboxes_4 + TF_FLARE_OFF);
				}
			}
		}
	}
};

void (float tno) decrement_team_ammoboxes =
{
	if ((tno == TF_FLARE_OFF))
	{
		num_team_ammoboxes_1 = (num_team_ammoboxes_1 - TF_FLARE_OFF);
	}
	else
	{
		if ((tno == BOT_FIGHTING))
		{
			num_team_ammoboxes_2 = (num_team_ammoboxes_2 - TF_FLARE_OFF);
		}
		else
		{
			if ((tno == BOT_AI_FOLLOW))
			{
				num_team_ammoboxes_3 = (num_team_ammoboxes_3 - TF_FLARE_OFF);
			}
			else
			{
				if ((tno == BOT_MOVING))
				{
					num_team_ammoboxes_4 = (num_team_ammoboxes_4 - TF_FLARE_OFF);
				}
			}
		}
	}
};

void () TeamFortress_AssaultWeapon =
{
	local float it;

	self.impulse = TF_FLARE_LIT;
	if ((self.tfstate & BOT_FIGHTING))
	{
		return;
	}
	if (!(self.weapons_carried & 32768))
	{
		return;
	}
	if ((self.heat > TF_FLARE_LIT))
	{
		sprint (self, BOT_FIGHTING, "the assault cannon is still overheated.\n");
		return;
	}
	if ((self.ammo_shells < TF_FLARE_OFF))
	{
		sprint (self, BOT_FIGHTING, "not enough ammo.\n");
		return;
	}
	if ((self.ammo_cells < BOT_AI_FLEE))
	{
		sprint (self, BOT_FIGHTING, "not enough cells to power the assault cannon.\n");
		return;
	}
	self.current_weapon = 32768;
	W_SetCurrentAmmo ();
};

void () TeamFortress_ExplodePerson =
{
	local entity te;

	self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & TF_FLARE_OFF));
	KickPlayer (-2, self.owner);
	newmis = spawn ();
	newmis.movetype = BOT_AI_SCOUT;
	newmis.solid = BOT_FIGHTING;
	newmis.classname = "grenade";
	newmis.team_no = self.owner.team_no;
	newmis.owner = self.owner;
	newmis.velocity = '0 0 0';
	newmis.angles = vectoangles (newmis.velocity);
	newmis.think = SUB_Null;
	newmis.nextthink = (time + 0.1);
	if ((self.weapon == TF_FLARE_OFF))
	{
		newmis.touch = NormalGrenadeTouch;
		newmis.think = NormalGrenadeExplode;
		newmis.skin = TF_FLARE_LIT;
		newmis.avelocity = '300 300 300';
		setmodel (newmis, "progs/hgren2.mdl");
	}
	else
	{
		if ((self.weapon == BOT_FIGHTING))
		{
			newmis.touch = ConcussionGrenadeTouch;
			newmis.think = ConcussionGrenadeExplode;
			newmis.skin = TF_FLARE_OFF;
			newmis.avelocity = '300 300 300';
			setmodel (newmis, "progs/hgren2.mdl");
		}
		else
		{
			if ((self.weapon == BOT_AI_FOLLOW))
			{
				newmis.touch = NailGrenadeTouch;
				newmis.think = NailGrenadeExplode;
				newmis.skin = TF_FLARE_OFF;
				newmis.avelocity = '0 300 0';
				setmodel (newmis, "progs/biggren.mdl");
			}
			else
			{
				if ((self.weapon == BOT_MOVING))
				{
					newmis.touch = MirvGrenadeTouch;
					newmis.think = MirvGrenadeExplode;
					newmis.skin = TF_FLARE_LIT;
					newmis.avelocity = '0 300 0';
					setmodel (newmis, "progs/biggren.mdl");
				}
				else
				{
					if ((self.weapon == BOT_AI_GRAPPLE))
					{
						newmis.touch = NapalmGrenadeTouch;
						newmis.think = NapalmGrenadeExplode;
						newmis.skin = BOT_FIGHTING;
						newmis.avelocity = '0 300 0';
						setmodel (newmis, "progs/biggren.mdl");
					}
					else
					{
						if ((self.weapon == BOT_AI_FLEE))
						{
							sprint (self.owner, BOT_FIGHTING, "Flare lit.\n");
							te = spawn ();
							te.touch = SUB_Null;
							te.think = RemoveFlare;
							te.nextthink = (time + 25);
							te.owner = self.owner;
							te.solid = TF_FLARE_LIT;
							self.owner.effects = (self.owner.effects | BOT_MOVING);
							dremove (self);
							dremove (newmis);
							return;
						}
						else
						{
							if ((self.weapon == BOT_AI_BLAST))
							{
								newmis.touch = GasGrenadeTouch;
								newmis.think = GasGrenadeExplode;
								newmis.skin = BOT_FIGHTING;
								newmis.avelocity = '300 300 300';
								setmodel (newmis, "progs/grenade2.mdl");
							}
							else
							{
								if ((self.weapon == BOT_DEFEND))
								{
									newmis.touch = EMPGrenadeTouch;
									newmis.think = EMPGrenadeExplode;
									newmis.skin = BOT_MOVING;
									newmis.avelocity = '300 300 300';
									setmodel (newmis, "progs/grenade2.mdl");
								}
								else
								{
									if ((self.weapon == BOT_AI_FLAGRUN))
									{
										newmis.touch = FlashGrenadeTouch;
										newmis.think = FlashGrenadeExplode;
										newmis.skin = TF_FLARE_OFF;
										newmis.avelocity = '300 300 300';
										setmodel (newmis, "progs/grenade2.mdl");
									}
								}
							}
						}
					}
				}
			}
		}
	}
	setsize (newmis, '0 0 0', '0 0 0');
	setorigin (newmis, self.owner.origin);
	bprint (TF_FLARE_OFF, "No ");
	bprint (TF_FLARE_OFF, self.owner.netname);
	bprint (TF_FLARE_OFF, ", throw the grenade, not the pin!\n");
	dremove (self);
};

void () NormalGrenadeTouch =
{
	if ((other == self.owner))
	{
		return;
	}
	sound (self, TF_FLARE_OFF, "weapons/bounce.wav", TF_FLARE_OFF, TF_FLARE_OFF);
	if ((self.velocity == '0 0 0'))
	{
		self.avelocity = '0 0 0';
	}
};

void () NormalGrenadeExplode =
{
	deathmsg = BOT_DEFEND;
	T_RadiusDamage (self, self.owner, 180, world);
	WriteByte (BOT_MOVING, 23);
	WriteByte (BOT_MOVING, BOT_AI_FOLLOW);
	WriteCoord (BOT_MOVING, self.origin_x);
	WriteCoord (BOT_MOVING, self.origin_y);
	WriteCoord (BOT_MOVING, self.origin_z);
	multicast (self.origin, TF_FLARE_OFF);
	dremove (self);
};

void () TeamFortress_DisplayDetectionItems =
{
	local entity Goal;
	local entity te;

	Goal = find (world, classname, "info_tfdetect");
	if (!Goal)
	{
		return;
	}
	if ((Goal.team_str_home == string_null))
	{
		return;
	}
	if ((Goal.display_item_status1 != TF_FLARE_LIT))
	{
		te = Finditem (Goal.display_item_status1);
		if (te)
		{
			DisplayItemStatus (Goal, self, te);
		}
		else
		{
			sprint (self, BOT_FIGHTING, "Item is missing.\n");
		}
	}
	else
	{
		return;
	}
	if ((Goal.display_item_status2 != TF_FLARE_LIT))
	{
		te = Finditem (Goal.display_item_status2);
		if (te)
		{
			DisplayItemStatus (Goal, self, te);
		}
		else
		{
			sprint (self, BOT_FIGHTING, "Item is missing.\n");
		}
	}
	else
	{
		return;
	}
	if ((Goal.display_item_status3 != TF_FLARE_LIT))
	{
		te = Finditem (Goal.display_item_status3);
		if (te)
		{
			DisplayItemStatus (Goal, self, te);
		}
		else
		{
			sprint (self, BOT_FIGHTING, "Item is missing.\n");
		}
	}
	else
	{
		return;
	}
	if ((Goal.display_item_status4 != TF_FLARE_LIT))
	{
		te = Finditem (Goal.display_item_status4);
		if (te)
		{
			DisplayItemStatus (Goal, self, te);
		}
		else
		{
			sprint (self, BOT_FIGHTING, "Item is missing.\n");
		}
	}
};

void () BioInfection_Decay =
{
	if ((((teamplay & BOT_RESUPPLYING) && (self.owner.team_no == self.enemy.team_no)) && (self.owner.team_no != TF_FLARE_LIT)))
	{
		self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & BOT_RESUPPLYING));
		dremove (self);
		return;
	}
	if ((self.invincible_finished > time))
	{
		self.owner.tfstate = (self.owner.tfstate - (self.owner.tfstate & BOT_RESUPPLYING));
		dremove (self);
		return;
	}
	self.nextthink = (time + BOT_FIGHTING);
	deathmsg = 13;
	TF_T_Damage (self.owner, self, self.enemy, BOT_AI_GRAPPLE, TF_FLARE_OFF, TF_FLARE_LIT);
	SpawnBlood (self.owner.origin, 30);
	if (!(self.owner.tfstate & BOT_RESUPPLYING))
	{
		dremove (self);
	}
};

void () BioInfection_MonsterDecay =
{
	self.nextthink = (time + BOT_FIGHTING);
	T_Damage (self.enemy, self, self.owner, BOT_AI_GRAPPLE);
	SpawnBlood (self.enemy.origin, 20);
	if ((self.enemy.health < TF_FLARE_OFF))
	{
		dremove (self);
	}
};

void (string halias, float himpulse1, float himpulse2) TeamFortress_Alias =
{
	local string imp;

	stuffcmd (self, "alias ");
	stuffcmd (self, halias);
	stuffcmd (self, " \"impulse ");
	imp = ftos (himpulse1);
	stuffcmd (self, imp);
	if ((himpulse2 != TF_FLARE_LIT))
	{
		stuffcmd (self, ";wait; impulse ");
		imp = ftos (himpulse2);
		stuffcmd (self, imp);
	}
	stuffcmd (self, "\"\n");
};

void () TeamFortress_Regenerate =
{
	if ((self.owner.playerclass == BOT_AI_GRAPPLE))
	{
		self.nextthink = (time + BOT_AI_FOLLOW);
		if ((self.owner.health >= self.owner.max_health))
		{
			return;
		}
		if ((self.owner.ammo_medikit == TF_FLARE_LIT))
		{
			return;
		}
		if ((self.owner.ammo_medikit < BOT_FIGHTING))
		{
			self.owner.health = (self.owner.health + self.owner.ammo_medikit);
			self.owner.ammo_medikit = TF_FLARE_LIT;
		}
		else
		{
			self.owner.health = (self.owner.health + BOT_FIGHTING);
			self.owner.ammo_medikit = (self.owner.ammo_medikit - BOT_FIGHTING);
		}
		if ((self.owner.health > self.owner.max_health))
		{
			self.owner.health = self.owner.max_health;
		}
	}
};

void () TeamFortress_RegenerateCells =
{
	if ((self.owner.playerclass == BOT_DEFEND))
	{
		self.nextthink = (time + BOT_AI_GRAPPLE);
		if ((self.owner.is_undercover == TF_FLARE_OFF))
		{
			if ((self.owner.ammo_cells == TF_FLARE_LIT))
			{
				self.owner.is_undercover = TF_FLARE_LIT;
				self.owner.modelindex = modelindex_player;
				self.owner.items = (self.owner.items - (self.owner.items & IT_INVISIBILITY));
			}
			else
			{
				self.owner.ammo_cells = (self.owner.ammo_cells - BOT_AI_FOLLOW);
				if ((self.owner.ammo_cells < TF_FLARE_LIT))
				{
					self.owner.ammo_cells = TF_FLARE_LIT;
				}
			}
		}
		else
		{
			if ((self.owner.ammo_cells >= self.owner.maxammo_cells))
			{
				return;
			}
			self.owner.ammo_cells = (self.owner.ammo_cells + TF_FLARE_OFF);
			if ((self.owner.ammo_cells > self.owner.maxammo_cells))
			{
				self.owner.ammo_cells = self.owner.maxammo_cells;
			}
		}
		return;
	}
};

void () TeamFortress_CheckforCheats =
{
	local float tf;
	local float pf;
	local string st;
	local vector vplf;
	local vector vf;

	self.nextthink = (time + BOT_FIGHTING);
	if ((self.owner.immune_to_check > time))
	{
		return;
	}
	if (self.owner.deadflag)
	{
		return;
	}
	if ((!(self.owner.flags & FL_ONGROUND) || (self.velocity_z != TF_FLARE_LIT)))
	{
		return;
	}
	vplf = self.owner.velocity;
	makevectors (self.owner.angles);
	vf = v_forward;
	vf_z = TF_FLARE_LIT;
	vf = normalize (vf);
	tf = ((vplf_x * vf_x) + (vplf_y * vf_y));
	pf = (self.owner.maxfbspeed + 100);
	if (((self.owner.tfstate & 65536) && (tf > 20)))
	{
		self.nextthink = (time + 0.5);
		self.owner.cheat_level = (self.owner.cheat_level + 600);
	}
	if ((tf > pf))
	{
		pf = (pf + 100);
		if ((tf > pf))
		{
			self.nextthink = (time + BOT_FIGHTING);
			self.owner.cheat_level = (self.owner.cheat_level + 300);
		}
		else
		{
			self.nextthink = (time + BOT_AI_FOLLOW);
			self.owner.cheat_level = (self.owner.cheat_level + 150);
		}
		TeamFortress_SetSpeed (self.owner);
	}
	if ((self.owner.cheat_level > 1200))
	{
		self.owner.cheat_level = TF_FLARE_LIT;
		bprint2 (TF_FLARE_OFF, self.owner.netname, " has been kicked for cheating.\n");
		sprint (self.owner, BOT_FIGHTING, "You have been kicked for cheating, because of your speed.\n");
		stuffcmd (self.owner, "disconnect\n");
	}
};

void () PlayerObserverMode =
{
	self.current_menu = TF_FLARE_OFF;
	self.impulse = TF_FLARE_LIT;
	self.playerclass = TF_FLARE_LIT;
	self.lives = TF_FLARE_LIT;
	self.team_no = CONTENT_EMPTY;
	self.flags = ((BOT_DEFEND | 128) | FL_ONGROUND);
	self.waterlevel = BOT_AI_FOLLOW;
	self.takedamage = TF_FLARE_LIT;
	self.solid = TF_FLARE_LIT;
	self.movetype = BOT_DEFEND;
	sprint (self, BOT_FIGHTING, "Observer mode\n");
	CenterPrint (self, "\n");
	stuffcmd (self, "cl_rollangle 0\n");
};

float (vector veca, vector vecb) crossproduct =
{
	local float result;

	result = ((veca_x * vecb_y) - (vecb_x * veca_y));
	return (result);
};
